#include "MissionFileWriter.h"
#include "MissionOptions.h"
#include "MissionGroup.h"
#include "FakeAirfield.h"
#include <fstream>
#include <filesystem>
#include "Resaver.h"
#include <codecvt>
#include <locale>

MissionFileWriter::MissionFileWriter(CampaignData& inCampaignData, int& SelectedPlayerPilot, SquadronMission& inMission)
	:m_CampaignData(inCampaignData)
	,m_SelectedPlayerPilotIndex(SelectedPlayerPilot)
	,m_Mission(inMission)
{
    SetupMissionOptions();
    m_MissionBounds = CalculateMissionBounds(inMission.missionPlan.missionWaypoints[0].WorldLocation, inMission.missionPlan.missionWaypoints);
}

void MissionFileWriter::SetupMissionOptions()
{
	auto missionOptions = CreateObject<MissionOptions>();

    missionOptions->LCName = AddLCTableItem("MissionName");
    missionOptions->LCDesc = AddLCTableItem("Mission Description");
    missionOptions->LCAuthor = AddLCTableItem("Mission Generated by Crosswind");;

	missionOptions->Time = ConvertTimeToFullFormat(m_CampaignData.CurrentDateTime.ToTimeString());
    missionOptions->Date = std::to_string(m_CampaignData.CurrentDateTime.day) + "." + std::to_string(m_CampaignData.CurrentDateTime.month) + "." + std::to_string(m_CampaignData.CurrentDateTime.year);
    
    missionOptions->HMap = m_CampaignData.CurrentWeather.mapData.HMap;
    missionOptions->Textures = m_CampaignData.CurrentWeather.mapData.Textures;
    missionOptions->Forests = m_CampaignData.CurrentWeather.mapData.Forests;
    missionOptions->GuiMap = m_CampaignData.CurrentWeather.mapData.GuiMap;
    missionOptions->SeasonPrefix = m_CampaignData.CurrentWeather.mapData.SeasonPrefix;
    missionOptions->MissionType = 0;

    missionOptions->CloudLevel = m_CampaignData.CurrentWeather.cloudBase;
    missionOptions->CloudHeight = m_CampaignData.CurrentWeather.cloudTop;
    missionOptions->PrecLevel = m_CampaignData.CurrentWeather.rainAmount;
    missionOptions->PrecType = m_CampaignData.CurrentWeather.rainType;
    missionOptions->CloudConfig = m_CampaignData.CurrentWeather.cloudConfig;
    missionOptions->SeaState = m_CampaignData.CurrentWeather.seaState;
    missionOptions->Turbulence = m_CampaignData.CurrentWeather.wind.turbulence;
    missionOptions->Temperature = m_CampaignData.CurrentWeather.airTemp;
    missionOptions->Pressure = m_CampaignData.CurrentWeather.airPressure;
    missionOptions->Haze = m_CampaignData.CurrentWeather.haze;
    missionOptions->LayerFog = 0;
    missionOptions->WindLayers = m_CampaignData.CurrentWeather.wind.windLevels;
    
    //default country setup
    std::vector<int> countrys = {0, 101, 102, 103, 201, 202, 203, 301, 302, 303, 304, 305, 401, 402, 901, 902, 903, 904};
    std::vector<int> sides = { 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 6, 7, 8, 9 };
    for (int i = 0; i < countrys.size(); ++i)
    {
        missionOptions->Countries.push_back({ countrys[i],sides[i] });
    }

    missionObjects.push_back(missionOptions);
}

void MissionFileWriter::WriteMissionFile()
{
    // 1. Build filename
    std::string fileName = m_Mission.missionPlan.missionType.name + "_" + m_Mission.missionPlan.missionDate.ToFilenameSafeString() + ".Mission";

    // 2. Optional: define full path
    std::filesystem::path filePath((Core::Instance().GetGamePath()) / "data" / "Missions" / "Crosswind" / fileName);

    // Ensure directory exists
    std::filesystem::create_directories(filePath.parent_path());

    // 3. Open file for writing
    std::ofstream outFile(filePath);
    if (!outFile.is_open())
    {
        std::cerr << "Failed to open mission file for writing: " << filePath.generic_string() << std::endl;
        return;
    }

    //start mission file
    outFile << "# Mission File Version = 1.0;" << "\n\n";

    // 4. Write each mission object
    for (const auto& object : missionObjects)
    {
        if (object)
        {
            std::string text = object->GetMissionFileText();

            // Print to console
            //std::cout << "Writing object:\n" << text << "\n------------------------\n";

            outFile << text << "\n\n"; // Extra line spacing between objects
        }
    }

    outFile << "# end of file";

    outFile.close();
    std::cout << "Mission file written to: " << filePath.generic_string() << std::endl;

    bool LCComplete = WriteLCTable();

    std::filesystem::path resaverPath = Core::Instance().GetGamePath() / "bin" / "resaver";

    Resaver resaverObject;
    resaverObject.RunResaver(resaverPath,filePath);

}

bool MissionFileWriter::WriteLCTable()
{
    // 1. Build filename
    std::string fileName = m_Mission.missionPlan.missionType.name + "_" + m_Mission.missionPlan.missionDate.ToFilenameSafeString() + ".eng";

    // 2. Optional: define full path
    std::filesystem::path filePath = std::filesystem::path(Core::Instance().GetGamePath()) / "data" / "Missions" / "Crosswind" / fileName;

    // Ensure directory exists
    std::filesystem::create_directories(filePath.parent_path());

    // 3. Open file in binary mode
    std::wofstream outFile(filePath, std::ios::binary);
    if (!outFile.is_open())
    {
        std::cerr << "Failed to open .eng file for writing: " << filePath.generic_string() << std::endl;
        return false;
    }

    // 4. Write UTF-16LE BOM
    outFile.put(0xFF);
    outFile.put(0xFE);

    // 5. Imbue the file with UTF-16LE codecvt
    outFile.imbue(std::locale(outFile.getloc(),
        new std::codecvt_utf16<wchar_t, 0x10ffff, std::little_endian>));

    // 6. Write LCTable content
    for (const auto& item : LCTable)
    {
        std::wstring line = std::to_wstring(item.first) + L":" + std::wstring(item.second.begin(), item.second.end()) + L"\n";
        outFile << line;
    }

    outFile.close();
    std::cout << ".eng file written to: " << filePath.generic_string() << std::endl;

    return true;
}

MissionBounds MissionFileWriter::CalculateMissionBounds(const Vec3& airfieldPos, const std::vector<MissionWaypoint>& waypoints, float padding)
{
    {
        if (waypoints.empty())
            return { airfieldPos, airfieldPos };

        Vec3 furthestPoint = waypoints.front().WorldLocation;
        float maxDistX = 0.0f;
        float maxDistZ = 0.0f;
        // Find furthest waypoint from the airfield
        for (const auto& wp : waypoints)
        {
            float dx = wp.WorldLocation.x - airfieldPos.x;
            float dz = wp.WorldLocation.z - airfieldPos.z;
            

            if (dx > maxDistX)
            {
                maxDistX = dx;
                furthestPoint.x = wp.WorldLocation.x;
            }
            if (dz > maxDistZ)
            {
                maxDistZ = dz;
                furthestPoint.z = wp.WorldLocation.z;
            }
        }

        // Compute the bounding box corners
        float minX = std::min(airfieldPos.x, furthestPoint.x);
        float maxX = std::max(airfieldPos.x, furthestPoint.x);
        float minZ = std::min(airfieldPos.z, furthestPoint.z);
        float maxZ = std::max(airfieldPos.z, furthestPoint.z);

        MissionBounds bounds;
        bounds.min = Vec3{ minX - padding, 0, minZ - padding };
        bounds.max = Vec3{ maxX + padding, 0, maxZ + padding };

        return bounds;
    }
}

void MissionFileWriter::ParseStaticObjectXml(const std::string& filePath)
{
    using namespace tinyxml2;

    XMLDocument doc;
    if (doc.LoadFile(filePath.c_str()) != XML_SUCCESS) {
        std::cerr << "Failed to load XML file: " << filePath << std::endl;
        return;
    }

    XMLElement* root = doc.FirstChildElement("Mission");
    if (!root) {
        std::cerr << "Missing Mission root node in XML file." << std::endl;
        return;
    }

    std::shared_ptr<MissionGroup> rootGroup = CreateObject<MissionGroup>();
    rootGroup->name = "StaticObjectGroup";

    std::vector<std::shared_ptr<MissionObject>> validObjects = ParseXmlElement(root, rootGroup, m_MissionBounds);

    for (int i = 0; i < validObjects.size(); ++i)
    {
        rootGroup->AddObjectToGroup(validObjects[i]);
    }
 
    missionObjects.push_back(rootGroup);
}

std::vector<std::shared_ptr<MissionObject>> MissionFileWriter::ParseXmlElement(tinyxml2::XMLElement* elem, std::shared_ptr<MissionGroup> currentGroup, const MissionBounds& missionBounds)
{
    using namespace tinyxml2;

    std::vector<std::shared_ptr<MissionObject>> validObjects;

    for (XMLElement* child = elem->FirstChildElement(); child; child = child->NextSiblingElement()) 
    {
        std::string type = child->Name();

        if (type == "Group") {

            std::vector<std::shared_ptr<MissionObject>> validChildren;

            for (tinyxml2::XMLElement* subChild = child->FirstChildElement(); subChild; subChild = subChild->NextSiblingElement())
            {
                std::string subChildType = subChild->Name();

                if (subChildType == "Block" || subChildType == "Bridge")
                {
                    if (XmlLocationWithinBounds(subChild))
                    {
                        //create object
                        auto newObject = CreateObject<WorldObject>(subChildType == "Block" ? EMissionObjectType::Block : EMissionObjectType::Bridge);
                        LoadWorldObjectAttributes(subChild, newObject.get());
                        validChildren.push_back(newObject);
                    }
                }
                else if (subChildType == "Group")
                {
                    std::vector<std::shared_ptr<MissionObject>> newValidObjects = ParseXmlElement(subChild, nullptr, missionBounds); //recursive
                    if (newValidObjects.size() > 0)
                    {
                        validChildren.insert(validChildren.end(), newValidObjects.begin(), newValidObjects.end());
                    }
                    
                }
            }

            //if we found any element that should be added, create the group
            if (validChildren.size() > 0)
            {
                auto newGroup = CreateObject<MissionGroup>();
                newGroup->name = child->Attribute("Name");
                newGroup->description = child->Attribute("Desc");

                for (int i = 0; i < validChildren.size(); ++i)
                {
                    newGroup->AddObjectToGroup(validChildren[i]);
                }

                validObjects.push_back(newGroup);
            }
        }
        else if (type == "Block" || type == "Bridge")
        {
            if (XmlLocationWithinBounds(child))
            {
                //create object
                auto newObject = CreateObject<WorldObject>(type == "Block" ? EMissionObjectType::Block : EMissionObjectType::Bridge);
                LoadWorldObjectAttributes(child, newObject.get());
                validObjects.push_back(newObject);
            }
        }

    }

    return validObjects;
}

void MissionFileWriter::AddAirfields(const Airfields* theaterAirfields)
{
    auto newGroup = CreateObject<MissionGroup>();
    newGroup->name = "AirfieldsGroup";
    int count = 0;
    for (const auto& airfield : theaterAirfields->LoadedAirfields)
    {
        auto newAirfield = CreateObject<FakeAirfield>();
        newAirfield->name = airfield.second.name;
        newAirfield->Pos = airfield.second.position;
        newAirfield->Ori = Vec3(airfield.second.orientation.xOri, airfield.second.orientation.yOri, airfield.second.orientation.zOri);
        newAirfield->Model = "graphics\\airfields\\fakefield.mgm";
        newAirfield->Script = "LuaScripts\\WorldObjects\\Airfields\\fakefield.txt";
        newAirfield->Country = airfield.second.country;
        newAirfield->description = "";
        newAirfield->Durability = 25000;
        newAirfield->DamageReport = 50;
        newAirfield->DamageThreshold = 1;
        newAirfield->DeleteAfterDeath = 1;
        newAirfield->Callsign = 21 + (count % 21);
        newAirfield->Callnum = 0;
        
        int index = 0;
        for (const auto& vec : airfield.second.runways.taxiToStart)
        {
            ChartPoint ChartPoint;
            ChartPoint.Type = index == 0 ? 0 : 1;
            Vec3 newFixedPos = Core::RotateXZ(vec - airfield.second.position, 360 - airfield.second.orientation.yOri);
            ChartPoint.X = newFixedPos.x;
            ChartPoint.Y = newFixedPos.z;
            newAirfield->Chart.push_back(ChartPoint);
            index++;
        }
        for (const auto& vec : { airfield.second.runways.startPos, airfield.second.runways.endPos })
        {
            ChartPoint ChartPoint;
            ChartPoint.Type = 2;
            Vec3 newFixedPos = Core::RotateXZ(vec - airfield.second.position, 360 - airfield.second.orientation.yOri);
            ChartPoint.X = newFixedPos.x;
            ChartPoint.Y = newFixedPos.z;
            newAirfield->Chart.push_back(ChartPoint);
        }
        index = 0;
        for (const auto& vec : airfield.second.runways.taxiFromEnd)
        {
            ChartPoint ChartPoint;
            ChartPoint.Type = index == (airfield.second.runways.taxiFromEnd.size() - 1) ? 0 : 1;
            Vec3 newFixedPos = Core::RotateXZ(vec - airfield.second.position, 360 - airfield.second.orientation.yOri);
            ChartPoint.X = newFixedPos.x;
            ChartPoint.Y = newFixedPos.z;
            newAirfield->Chart.push_back(ChartPoint);
            index++;
        }
        
        newGroup->AddObjectToGroup(newAirfield);
    }
    missionObjects.push_back(newGroup);
}



void MissionFileWriter::LoadWorldObjectAttributes(tinyxml2::XMLElement* elem, WorldObject* object)
{
    object->name = elem->Attribute("Name");
    elem->QueryFloatAttribute("XPos", &object->Pos.x);
    elem->QueryFloatAttribute("YPos", &object->Pos.y);
    elem->QueryFloatAttribute("ZPos", &object->Pos.z);
    elem->QueryFloatAttribute("XOri", &object->Ori.x);
    elem->QueryFloatAttribute("YOri", &object->Ori.y);
    elem->QueryFloatAttribute("ZOri", &object->Ori.z);
    object->Model = elem->Attribute("Model");
    object->Script = elem->Attribute("Script");
    elem->QueryIntAttribute("Country", &object->Country);
    object->description = elem->Attribute("Desc");
    elem->QueryIntAttribute("Durability", &object->Durability);
    elem->QueryIntAttribute("DamageReport", &object->DamageReport);
    elem->QueryIntAttribute("DamageThreshold", &object->DamageThreshold);
    elem->QueryIntAttribute("DeleteAfterDeath", &object->DeleteAfterDeath);

    auto* damagedElem = elem->FirstChildElement("Damaged");
    if (damagedElem)
    {
        std::vector<std::pair<int, int>> damagedPairs;

        const tinyxml2::XMLAttribute* attr = damagedElem->FirstAttribute();
        while (attr)
        {
            std::string name = attr->Name();  // e.g., "key_12"
            int key = -1;

            if (name.rfind("key_", 0) == 0) // starts with "key_"
            {
                try {
                    key = std::stoi(name.substr(4));
                    int value = std::stoi(attr->Value());
                    damagedPairs.emplace_back(key, value);
                }
                catch (...) {
                    // Handle malformed key/value if needed
                }
            }

            attr = attr->Next();

        }

        object->Damaged = damagedPairs;
    }
    
        
}

void MissionFileWriter::LoadGroupAttributes(tinyxml2::XMLElement* elem, MissionGroup* currentGroup)
{
    using namespace tinyxml2;

    currentGroup->name = elem->Attribute("Name");
    currentGroup->description = elem->Attribute("Desc");

}

bool MissionFileWriter::XmlLocationWithinBounds(tinyxml2::XMLElement* elem)
{
    using namespace tinyxml2;
    Vec3 elementPos;
    elem->QueryFloatAttribute("XPos", &elementPos.x);
    elem->QueryFloatAttribute("ZPos", &elementPos.z);

    return IsWithinMissionBounds(elementPos);
}

bool MissionFileWriter::IsWithinMissionBounds(const Vec3& position)
{
    return position.x >= m_MissionBounds.min.x && position.x <= m_MissionBounds.max.x &&
        position.z >= m_MissionBounds.min.z && position.z <= m_MissionBounds.max.z;
}

int MissionFileWriter::AddLCTableItem(std::string text)
{
    int size = LCTable.size();
    LCTable.push_back({ size,text });

    return size;
}

std::string MissionFileWriter::ConvertTimeToFullFormat(const std::string& timeStr)
{
    int hours = 0;
    int minutes = 0;

    if (sscanf_s(timeStr.c_str(), "%d:%d", &hours, &minutes) == 2)
    {
        char buffer[9]; // "H:MM:SS" needs up to 8 chars + null terminator
        snprintf(buffer, sizeof(buffer), "%d:%02d:00", hours, minutes);
        return std::string(buffer);
    }

    // If parsing fails, return a default or error value
    return "0:00:00";
}